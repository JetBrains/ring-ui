window.source = {
  "title": "Auth",
  "url": "auth.html",
  "type": "js",
  "content": "import 'core-js/modules/es7.array.includes';\nimport 'whatwg-fetch';\n\nimport {fixUrl, getAbsoluteBaseURL} from '../global/url';\nimport Listeners from '../global/listeners';\nimport HTTP from '../http/http';\nimport promiseWithTimeout from '../global/promise-with-timeout';\n\nimport AuthStorage from './storage';\nimport AuthResponseParser from './response-parser';\nimport AuthRequestBuilder from './request-builder';\nimport WindowFlow from './window-flow';\nimport BackgroundFlow from './background-flow';\nimport TokenValidator from './token-validator';\nimport defaultOnBackendDown from './down-notification';\n\n\n/**\n * @name Auth\n * @category Utilities\n * @tags Ring UI Language\n * @description Authenticates a user in [Hub](https://www.jetbrains.com/hub/).\n *\n * @prop {object} config\n * @prop {string} config.serverUri\n * @prop {string} config.redirectUri\n * @prop {string} config.clientId\n * @prop {boolean=false} config.redirect â€” use redirects instead of loading the token in the background.\n * @prop {string[]} config.scope\n * @prop {string[]} config.optionalScopes\n * @prop {boolean} config.cleanHash - whether or not location.hash will be cleaned after authorization is completed.\n * Should be set to false in angular > 1.2.26 apps to prevent infinite redirect in Firefox\n * @prop {User?} user\n * @prop {string[]} config.userFields List of user data fields to be returned by auth.requestUser (default list is used in Header.HeaderHelper)\n * @prop {string[]} config.fetchCredentials\n *\n * @param {{\n *   serverUri: string,\n *   redirectUri: string?,\n *   requestCredentials: string?,\n *   clientId: string?,\n *   scope: string[]?,\n *   optionalScopes: string[]?,\n *   cleanHash: boolean?,\n *   fetchCredentials: string?,\n *   userFields: string[]?\n * }} config\n *\n * @example-file ./auth.examples.html\n */\n\n/* eslint-disable no-magic-numbers */\nexport const DEFAULT_EXPIRES_TIMEOUT = 40 * 60;\nexport const DEFAULT_BACKGROUND_TIMEOUT = 10 * 1000;\nconst DEFAULT_BACKEND_CHECK_TIMEOUT = 10 * 1000;\nconst BACKGROUND_REDIRECT_TIMEOUT = 20 * 1000;\n/* eslint-enable no-magic-numbers */\n\nexport const USER_CHANGED_EVENT = 'userChange';\nexport const DOMAIN_USER_CHANGED_EVENT = 'domainUser';\nexport const LOGOUT_EVENT = 'logout';\nexport const LOGOUT_POSTPONED_EVENT = 'logoutPostponed';\nexport const USER_CHANGE_POSTPONED_EVENT = 'changePostponed';\n\nfunction noop() {}\n\nconst DEFAULT_CONFIG = {\n  reloadOnUserChange: true,\n  embeddedLogin: false,\n  EmbeddedLoginFlow: WindowFlow,\n  clientId: '0-0-0-0-0',\n  redirectUri: getAbsoluteBaseURL(),\n  redirect: false,\n  requestCredentials: 'default',\n  backgroundRefreshTimeout: null,\n  scope: [],\n  userFields: ['guest', 'id', 'name', 'profile/avatar/url'],\n  cleanHash: true,\n  onLogout: noop,\n  onPostponeChangedUser: () => {},\n  onPostponeLogout: () => {},\n  enableBackendStatusCheck: true,\n  backendCheckTimeout: DEFAULT_BACKEND_CHECK_TIMEOUT,\n  checkBackendIsUp: () => Promise.resolve(null),\n  onBackendDown: defaultOnBackendDown,\n\n  defaultExpiresIn: DEFAULT_EXPIRES_TIMEOUT,\n  translations: {\n    login: 'Log in',\n    loginTo: 'Log in to %serviceName%',\n    cancel: 'Cancel',\n    postpone: 'Postpone',\n    youHaveLoggedInAs: 'You have logged in as another user: %userName%',\n    applyChange: 'Apply change',\n    backendIsNotAvailable: 'Backend is not available',\n    checkAgain: 'Check again',\n    nothingHappensLink: 'Click here if nothing happens'\n  }\n};\n\nexport default class Auth {\n  static DEFAULT_CONFIG = DEFAULT_CONFIG;\n  static API_PATH = 'api/rest/';\n  static API_AUTH_PATH = 'oauth2/auth';\n  static API_PROFILE_PATH = 'users/me';\n  static CLOSE_BACKEND_DOWN_MESSAGE = 'backend-check-succeeded';\n  static CLOSE_WINDOW_MESSAGE = 'close-login-window';\n  static shouldRefreshToken = TokenValidator.shouldRefreshToken;\n\n  config = {};\n  listeners = new Listeners();\n  http = null;\n  _service = {};\n  _storage = null;\n  _responseParser = new AuthResponseParser();\n  _requestBuilder = null;\n  _backgroundFlow = null;\n  _embeddedFlow = null;\n  _tokenValidator = null;\n  _postponed = false;\n  _backendCheckPromise = null;\n  _authDialogService = undefined;\n\n  constructor(config) {\n    if (!config) {\n      throw new Error('Config is required');\n    }\n\n    if (config.serverUri == null) {\n      throw new Error('\\\"serverUri\\\" property is required');\n    }\n\n    const unsupportedParams = ['redirect_uri', 'request_credentials', 'client_id'].filter(param => config.hasOwnProperty(param));\n    if (unsupportedParams.length !== 0) {\n      throw new Error(`The following parameters are no longer supported: ${unsupportedParams.join(', ')}. Please change them from snake_case to camelCase.`);\n    }\n\n    config.userFields = config.userFields || [];\n\n    this.config = {...Auth.DEFAULT_CONFIG, ...config};\n\n    const {clientId, redirect, redirectUri, requestCredentials, scope} = this.config;\n    const serverUriLength = this.config.serverUri.length;\n\n    if (serverUriLength > 0 && this.config.serverUri.charAt(serverUriLength - 1) !== '/') {\n      this.config.serverUri += '/';\n    }\n\n    this.config.userParams = {\n      query: {\n        fields: [...new Set(Auth.DEFAULT_CONFIG.userFields.concat(config.userFields))].join()\n      }\n    };\n\n    if (!scope.includes(Auth.DEFAULT_CONFIG.clientId)) {\n      scope.push(Auth.DEFAULT_CONFIG.clientId);\n    }\n\n    this._storage = new AuthStorage({\n      messagePrefix: `${clientId}-message-`,\n      stateKeyPrefix: `${clientId}-states-`,\n      tokenKey: `${clientId}-token`\n    });\n\n    this._domainStorage = new AuthStorage({messagePrefix: 'domain-message-'});\n\n    this._requestBuilder = new AuthRequestBuilder({\n      authorization: this.config.serverUri + Auth.API_PATH + Auth.API_AUTH_PATH,\n      clientId,\n      redirect,\n      redirectUri,\n      requestCredentials,\n      scopes: scope\n    }, this._storage);\n\n    let {backgroundRefreshTimeout} = this.config;\n    if (!backgroundRefreshTimeout) {\n      backgroundRefreshTimeout = this.config.embeddedLogin\n        ? DEFAULT_BACKGROUND_TIMEOUT\n        : BACKGROUND_REDIRECT_TIMEOUT;\n    }\n\n    this._backgroundFlow = new BackgroundFlow(\n      this._requestBuilder, this._storage, backgroundRefreshTimeout\n    );\n    this._embeddedFlow = new this.config.EmbeddedLoginFlow(\n      this._requestBuilder,\n      this._storage,\n      this.config.translations\n    );\n\n    const API_BASE = this.config.serverUri + Auth.API_PATH;\n    const fetchConfig = config.fetchCredentials\n      ? {credentials: config.fetchCredentials}\n      : undefined;\n    this.http = new HTTP(this, API_BASE, fetchConfig);\n\n    const getUser = async token => {\n      const user = await this.getUser(token);\n      this.user = user;\n      return user;\n    };\n\n    this._tokenValidator = new TokenValidator(this.config, getUser, this._storage);\n\n    if (this.config.onLogout) {\n      this.addListener(LOGOUT_EVENT, this.config.onLogout);\n    }\n\n    if (this.config.reloadOnUserChange === true) {\n      this.addListener(USER_CHANGED_EVENT, () => this._reloadCurrentPage());\n    }\n\n    this.addListener(LOGOUT_POSTPONED_EVENT, () => this._setPostponed(true));\n    this.addListener(USER_CHANGE_POSTPONED_EVENT, () => this._setPostponed(true));\n    this.addListener(USER_CHANGED_EVENT, () => this._setPostponed(false));\n    this.addListener(USER_CHANGED_EVENT, user => user && this._updateDomainUser(user.id));\n\n    this._createInitDeferred();\n\n    this.setUpPreconnect(config.serverUri);\n  }\n\n  _setPostponed(postponed = false) {\n    this._postponed = postponed;\n  }\n\n  _updateDomainUser(userID) {\n    this._domainStorage.sendMessage(DOMAIN_USER_CHANGED_EVENT, {\n      userID,\n      serviceID: this.config.clientId\n    });\n  }\n\n  addListener(event, handler) {\n    this.listeners.add(event, handler);\n  }\n\n  removeListener(event, handler) {\n    this.listeners.remove(event, handler);\n  }\n\n  setAuthDialogService(authDialogService) {\n    this._authDialogService = authDialogService;\n  }\n\n  setCurrentService(service) {\n    this._service = service;\n  }\n\n  _createInitDeferred() {\n    this._initDeferred = {};\n    this._initDeferred.promise = new Promise((resolve, reject) => {\n      this._initDeferred.resolve = resolve;\n      this._initDeferred.reject = reject;\n    });\n  }\n\n  /**\n   * @return {Promise.<string>} absolute URL promise that is resolved to a URL\n   * that should be restored after returning back from auth server.\n   */\n  async init() {\n    this._storage.onTokenChange(token => {\n      const isGuest = this.user ? this.user.guest : false;\n\n      if (isGuest && !token) {\n        return;\n      }\n\n      if (!token) {\n        this.logout();\n      } else {\n        this._detectUserChange(token.accessToken);\n      }\n    });\n\n    this._domainStorage.onMessage(DOMAIN_USER_CHANGED_EVENT, ({userID, serviceID}) => {\n      if (serviceID === this.config.clientId) {\n        return;\n      }\n      if (this.user && userID === this.user.id) {\n        return;\n      }\n      this.forceTokenUpdate();\n    });\n\n    let state;\n\n    try {\n      // Look for token or error in hash\n      state = await this._checkForAuthResponse();\n    } catch (error) {\n      return this.handleInitError(error);\n    }\n\n    // Return endless promise in the background to avoid service start\n    if (state && state.nonRedirect) {\n      return new Promise(noop);\n    }\n\n    try {\n      // Check if there is a valid token\n      await this._tokenValidator.validateToken();\n\n\n      // Checking if there is a message left by another app on this domain\n      const message = await this._domainStorage._messagesStorage.get(`domain-message-${DOMAIN_USER_CHANGED_EVENT}`);\n      if (message) {\n        const {userID, serviceID} = message;\n        if (serviceID !== this.config.clientId && (!userID || this.user.id !== userID)) {\n          this.forceTokenUpdate();\n        }\n      }\n\n      // Access token appears to be valid.\n      // We may resolve restoreLocation URL now\n      this._initDeferred.resolve(state && state.restoreLocation);\n      return state && state.restoreLocation;\n    } catch (error) {\n      return this.handleInitValidationError(error);\n    }\n  }\n\n  async sendRedirect(error) {\n    const authRequest = await this._requestBuilder.prepareAuthRequest();\n    this._redirectCurrentPage(authRequest.url);\n\n    throw error;\n  }\n\n  async handleInitError(error) {\n    if (error.stateId) {\n      try {\n        const state = await this._storage.getState(error.stateId);\n\n        if (state && state.nonRedirect) {\n          state.error = error;\n          this._storage.saveState(error.stateId, state);\n\n          // Return endless promise in the background to avoid service start\n          return new Promise(noop);\n        }\n      } catch (e) {\n        // Throw the orginal error instead below\n      }\n    }\n\n    throw error;\n  }\n\n  async handleInitValidationError(error) {\n    // Redirect flow\n    if (error.authRedirect && this.config.redirect) {\n      return this.sendRedirect(error);\n    }\n\n    // Background flow\n    if (error.authRedirect && !this.config.redirect) {\n      try {\n        await this._backgroundFlow.authorize();\n        await this._tokenValidator.validateToken();\n        this._initDeferred.resolve();\n        return undefined;\n      } catch (validationError) {\n        // Fallback to redirect flow\n        return this.sendRedirect(validationError);\n      }\n    }\n\n    this._initDeferred.reject(error);\n    throw error;\n  }\n\n  /**\n   * Get token from local storage or request it if necessary.\n   * Can redirect to login page.\n   * @return {Promise.<string>}\n   */\n  async requestToken() {\n    if (this._postponed) {\n      throw new Error('You should log in to be able to make requests');\n    }\n\n    try {\n      await this._initDeferred.promise;\n\n      return await this._tokenValidator.validateTokenLocally();\n    } catch (e) {\n      return this.forceTokenUpdate();\n    }\n  }\n\n  /**\n   * Get new token in the background or redirect to the login page.\n   * @return {Promise.<string>}\n   */\n  async forceTokenUpdate() {\n    try {\n      if (!this._backendCheckPromise) {\n        this._backendCheckPromise = this._checkBackendsStatusesIfEnabled();\n      }\n      await this._backendCheckPromise;\n    } catch (e) {\n      throw new Error('Cannot refresh token: backend is not available. Postponed by user.');\n    } finally {\n      this._backendCheckPromise = null;\n    }\n\n    try {\n      return await this._backgroundFlow.authorize();\n    } catch (error) {\n\n      if (this._canShowDialogs()) {\n        return this._showAuthDialog({nonInteractive: true, error});\n      } else {\n        const authRequest = await this._requestBuilder.prepareAuthRequest();\n        this._redirectCurrentPage(authRequest.url);\n      }\n\n      throw new TokenValidator.TokenValidationError(error.message);\n    }\n  }\n\n  async loadCurrentService() {\n    if (this._service.serviceName) {\n      return;\n    }\n    try {\n      const {serviceName, iconUrl: serviceImage} = await this.http.get(`oauth2/interactive/login/settings?client_id=${this.config.clientId}`) || {};\n      this.setCurrentService({serviceImage, serviceName});\n    } catch (e) {\n      // noop\n    }\n  }\n\n  getAPIPath() {\n    return this.config.serverUri + Auth.API_PATH;\n  }\n\n  /**\n   * @return {Promise.<object>}\n   */\n  getUser(accessToken) {\n    return this.http.authorizedFetch(Auth.API_PROFILE_PATH, accessToken, this.config.userParams);\n  }\n\n  /**\n   * @return {Promise.<object>}\n   */\n  async requestUser() {\n    if (this.user) {\n      return this.user;\n    }\n\n    const accessToken = await this.requestToken();\n\n    // If user was fetched during token request\n    if (this.user) {\n      return this.user;\n    }\n\n    const user = await this.getUser(accessToken);\n    this.user = user;\n\n    return user;\n  }\n\n  async updateUser() {\n    this._setPostponed(false);\n    const accessToken = await this.requestToken();\n    const user = await this.getUser(accessToken);\n    this.user = user;\n    this.listeners.trigger(USER_CHANGED_EVENT, user);\n  }\n\n  async _detectUserChange(accessToken) {\n    const windowWasOpen = this._isLoginWindowOpen;\n\n    try {\n      const user = await this.getUser(accessToken);\n      const onApply = () => {\n        this.user = user;\n        this.listeners.trigger(USER_CHANGED_EVENT, user);\n      };\n\n      if (user && this.user && this.user.id !== user.id) {\n        if (!this._canShowDialogs() || this.user.guest || windowWasOpen) {\n          onApply();\n          return;\n        }\n        if (user.guest) {\n          this._showAuthDialog({nonInteractive: true});\n          return;\n        }\n\n        await this._showUserChangedDialog({\n          newUser: user,\n          onApply,\n          onPostpone: () => {\n            this.listeners.trigger(USER_CHANGE_POSTPONED_EVENT);\n            this.config.onPostponeChangedUser(this.user, user);\n          }\n        });\n\n      }\n    } catch (e) {\n      // noop\n    }\n  }\n\n  _beforeLogout(params) {\n    if (this._canShowDialogs()) {\n      this._showAuthDialog(params);\n      return;\n    }\n\n    this.logout();\n  }\n\n  async _showAuthDialog({nonInteractive, error, canCancel} = {}) {\n    const {embeddedLogin, onPostponeLogout, translations} = this.config;\n    const cancelable = this.user.guest || canCancel;\n\n    this._createInitDeferred();\n\n    const closeDialog = () => {\n      /* eslint-disable no-use-before-define */\n      stopTokenListening();\n      stopMessageListening();\n      hide();\n      /* eslint-enable no-use-before-define */\n    };\n\n    const onConfirm = () => {\n      if (embeddedLogin !== true) {\n        closeDialog();\n        this.logout();\n        return;\n      }\n      this._runEmbeddedLogin();\n    };\n\n    const onCancel = () => {\n      this._embeddedFlow.stop();\n      this._storage.sendMessage(Auth.CLOSE_WINDOW_MESSAGE, Date.now());\n      closeDialog();\n      if (!cancelable) {\n        this._initDeferred.resolve();\n        this.listeners.trigger(LOGOUT_POSTPONED_EVENT);\n        onPostponeLogout();\n        return;\n      }\n\n      if (this.user.guest && nonInteractive) {\n        this.forceTokenUpdate();\n      } else {\n        this._initDeferred.resolve();\n      }\n    };\n\n    const hide = this._authDialogService({\n      ...this._service,\n      loginCaption: translations.login,\n      loginToCaption: translations.loginTo,\n      confirmLabel: translations.login,\n      cancelLabel: cancelable ? translations.cancel : translations.postpone,\n      errorMessage: error && error.toString ? error.toString() : null,\n      onConfirm,\n      onCancel\n    });\n\n    const stopTokenListening = this._storage.onTokenChange(token => {\n      if (token) {\n        closeDialog();\n        this._initDeferred.resolve();\n      }\n    });\n\n    const stopMessageListening = this._storage.onMessage(\n      Auth.CLOSE_WINDOW_MESSAGE,\n      () => this._embeddedFlow.stop()\n    );\n  }\n\n  async _showUserChangedDialog({newUser, onApply, onPostpone} = {}) {\n    const {translations} = this.config;\n\n    this._createInitDeferred();\n\n    const done = () => {\n      this._initDeferred.resolve();\n      // eslint-disable-next-line no-use-before-define\n      hide();\n    };\n\n    const hide = this._authDialogService({\n      ...this._service,\n      title: translations.youHaveLoggedInAs.replace('%userName%', newUser.name),\n      loginCaption: translations.login,\n      loginToCaption: translations.loginTo,\n      confirmLabel: translations.applyChange,\n      cancelLabel: translations.postpone,\n      onConfirm: () => {\n        done();\n        onApply();\n      },\n      onCancel: () => {\n        done();\n        onPostpone();\n      }\n    });\n  }\n\n  async _showBackendDownDialog(backendError) {\n    const {onBackendDown, translations} = this.config;\n    const REPEAT_TIMEOUT = 5000;\n    let timerId = null;\n\n    return new Promise((resolve, reject) => {\n      const done = () => {\n        /* eslint-disable no-use-before-define */\n        hide();\n        window.removeEventListener('online', onCheckAgain);\n        stopListeningCloseMessage();\n        /* eslint-enable no-use-before-define */\n        this._storage.sendMessage(Auth.CLOSE_BACKEND_DOWN_MESSAGE, Date.now());\n        this._awaitingForBackendPromise = null;\n        clearTimeout(timerId);\n      };\n\n      const stopListeningCloseMessage = this._storage.onMessage(\n        Auth.CLOSE_BACKEND_DOWN_MESSAGE,\n        () => {\n          stopListeningCloseMessage();\n          done();\n          resolve();\n        }\n      );\n\n      const onCheckAgain = async () => {\n        await this._checkBackendsAreUp();\n        done();\n        resolve();\n      };\n\n      const onPostpone = () => {\n        done();\n        reject(new Error('Auth(@jetbrains/ring-ui): postponed by user'));\n      };\n\n      const hide = onBackendDown({onCheckAgain, onPostpone, backendError, translations});\n\n      window.addEventListener('online', onCheckAgain);\n\n      function networkWatchdog() {\n        if (navigator && navigator.onLine) {\n          onCheckAgain();\n        }\n        timerId = setTimeout(networkWatchdog, REPEAT_TIMEOUT);\n      }\n\n      timerId = setTimeout(networkWatchdog, REPEAT_TIMEOUT);\n    });\n  }\n\n  /**\n   * Wipe accessToken and redirect to auth page with required authorization\n   */\n  async logout(extraParams) {\n    const requestParams = {\n      // eslint-disable-next-line camelcase\n      request_credentials: 'required',\n      ...extraParams\n    };\n\n    await this._checkBackendsStatusesIfEnabled();\n    await this.listeners.trigger(LOGOUT_EVENT);\n    this._updateDomainUser(null);\n    await this._storage.wipeToken();\n\n    const authRequest = await this._requestBuilder.prepareAuthRequest(requestParams);\n    this._redirectCurrentPage(authRequest.url);\n  }\n\n  async _runEmbeddedLogin() {\n    this._storage.sendMessage(Auth.CLOSE_WINDOW_MESSAGE, Date.now());\n    try {\n      this._isLoginWindowOpen = true;\n      return await this._embeddedFlow.authorize();\n    } catch (e) {\n      throw e;\n    } finally {\n      this._isLoginWindowOpen = false;\n    }\n  }\n\n  /**\n   * Wipe accessToken and redirect to auth page to obtain authorization data\n   * if user is logged in or log her in otherwise\n   */\n  async login() {\n    if (this.config.embeddedLogin) {\n      await this._runEmbeddedLogin();\n      return;\n    }\n\n    await this._checkBackendsStatusesIfEnabled();\n    try {\n      const accessToken = await this._backgroundFlow.authorize();\n      const user = await this.getUser(accessToken);\n\n      if (user.guest) {\n        this._beforeLogout();\n      } else {\n        this.user = user;\n        this.listeners.trigger(USER_CHANGED_EVENT, user);\n      }\n    } catch (e) {\n      this._beforeLogout();\n    }\n  }\n\n  async switchUser() {\n    if (this.config.embeddedLogin) {\n      await this._runEmbeddedLogin();\n    }\n\n    throw new Error('Auth: switchUser only supported for \"embeddedLogin\" mode');\n  }\n\n  /**\n   * Check if the hash contains an access token.\n   * If it does, extract the state, compare with\n   * config, and store the auth response for later use.\n   *\n   * @return {Promise} promise that is resolved to restoreLocation URL, or rejected\n   * @private\n   */\n  async _checkForAuthResponse() {\n    // getAuthResponseURL may throw an exception\n    const authResponse = this._responseParser.getAuthResponseFromURL();\n    const {scope: defaultScope, defaultExpiresIn, cleanHash} = this.config;\n\n    if (authResponse && cleanHash) {\n      this.setHash('');\n    }\n\n    if (!authResponse) {\n      return undefined;\n    }\n\n    const {state: stateId, scope, expiresIn, accessToken} = authResponse;\n    const newState = await (stateId && this._storage.getState(stateId)) || {};\n\n    const scopes = scope ? scope.split(' ') : newState.scopes || defaultScope || [];\n    const effectiveExpiresIn = expiresIn ? parseInt(expiresIn, 10) : defaultExpiresIn;\n    const expires = TokenValidator._epoch() + effectiveExpiresIn;\n\n    await this._storage.saveToken({accessToken, scopes, expires, lifeTime: effectiveExpiresIn});\n\n    return newState;\n  }\n\n  _checkBackendsAreUp() {\n    const {backendCheckTimeout} = this.config;\n    return Promise.all([\n      promiseWithTimeout(\n        this.http.fetch('settings/public?fields=id'),\n        backendCheckTimeout,\n        {error: new Error('The authorization server is taking too long to respond. Please try again later.')}\n      ),\n      this.config.checkBackendIsUp()\n    ]).catch(err => {\n      if (err instanceof TypeError) {\n        throw new TypeError('Could not connect to the server due to network error. Please check your connection and try again.');\n      }\n      throw err;\n    });\n  }\n\n  async _checkBackendsStatusesIfEnabled() {\n    if (!this.config.enableBackendStatusCheck) {\n      return;\n    }\n    try {\n      await this._checkBackendsAreUp();\n    } catch (backendDownErr) {\n      await this._showBackendDownDialog(backendDownErr);\n    }\n  }\n\n  /**\n   * Adds preconnect tag to help browser to establish connection to URL.\n   * See https://w3c.github.io/resource-hints/\n   * @param url Url to preconnect to.\n   */\n  async setUpPreconnect(url) {\n    const linkNode = document.createElement('link');\n    linkNode.rel = 'preconnect';\n    linkNode.href = url;\n    linkNode.pr = '1.0';\n    document.head.appendChild(linkNode);\n  }\n\n  /**\n   * Redirects current page to the given URL\n   * @param {string} url\n   * @private\n   */\n  _redirectCurrentPage(url) {\n\n    window.location = fixUrl(url);\n  }\n\n  /**\n   * Reloads current page\n   */\n  _reloadCurrentPage() {\n    this._redirectCurrentPage(window.location.href);\n  }\n\n  _canShowDialogs() {\n    return this.config.embeddedLogin && this._authDialogService;\n  }\n\n  /**\n   * Sets the location hash\n   * @param {string} hash\n   */\n  setHash(hash) {\n    if (history.replaceState) {\n      // NB! History.replaceState is used here, because Firefox saves\n      // a record in history.\n      // NB! URL to redirect is formed manually because baseURI could be messed up,\n      // in which case it's not obvious where redirect will lead.\n      const cleanedUrl = [\n        window.location.pathname,\n        window.location.search\n      ].join('');\n\n      const hashIfExist = hash ? `#${hash}` : '';\n\n      history.replaceState(undefined, undefined, `${cleanedUrl}${hashIfExist}`);\n    } else {\n      window.location.hash = hash;\n    }\n  }\n}\n",
  "examples": [
    {
      "name": "Auth",
      "url": "examples/auth/auth.html",
      "disableAutoSize": false,
      "files": [
        {
          "type": "html",
          "content": "\n<div><a href=\"#\" id=\"force-update\" hidden=\"true\" class=\"ring-link\">Force token update</a></div>\n<div id=\"example\"></div>\n  ",
          "showCode": true
        },
        {
          "type": "js",
          "content": "\nimport Auth from '@jetbrains/ring-ui/components/auth/auth';\nimport authDialogService from '@jetbrains/ring-ui/components/auth-dialog-service/auth-dialog-service';\nimport hubConfig from '@ring-ui/docs/components/hub-config';\nimport '@jetbrains/ring-ui/components/link/link__legacy.css';\n// Example config:\n// var hubConfig = {\n//   serverUri: 'https://hub.jetbrains.com/',\n//   clientId: '81a0bffb-6d0f-4a38-b93a-0a4d1e567698',\n//   requestCredentials: 'skip',\n//   redirectUri: window.location.href.split('#')[0]\n// };\n\nconst log = function (title, obj) {\n  const titleElem = document.createElement('b');\n  const jsonElem = document.createElement('span');\n  const lineBreak = document.createElement('br');\n  lineBreak.style.lineHeight = '32px';\n\n  titleElem.innerHTML = title + ' ';\n  jsonElem.innerHTML = JSON.stringify(obj) + '\\n';\n\n  document.getElementById('example').appendChild(titleElem);\n  document.getElementById('example').appendChild(jsonElem);\n  document.getElementById('example').appendChild(lineBreak);\n};\n\nconst auth = new Auth(hubConfig);\nauth.setAuthDialogService(authDialogService);\n\n(async () => {\n  try {\n    const location = await auth.init();\n    log('Location to restore:', location)\n    const token = await auth.requestToken();\n    log('Token:', token);\n    const data = await auth.requestUser();\n    log('User profile data:', data);\n  } catch (e) {\n    log('error', e);\n  }\n\n  const forceUpdateLink = document.querySelector('#force-update');\n  forceUpdateLink.hidden = false;\n\n  forceUpdateLink.addEventListener('click', async () => {\n    const newToken = await auth.forceTokenUpdate();\n    log('Token has been refreshed:', newToken);\n  });\n})();\n  ",
          "showCode": true
        }
      ]
    },
    {
      "name": "Auth in iframe",
      "url": "examples/auth/auth-in-iframe.html",
      "disableAutoSize": true,
      "files": [
        {
          "type": "html",
          "content": "\n<div id=\"example\"></div>\n  ",
          "showCode": true
        },
        {
          "type": "js",
          "content": "\nimport Auth from '@jetbrains/ring-ui/components/auth/auth';\nimport IFrameFlow from '@jetbrains/ring-ui/components/auth/iframe-flow'\nimport authDialogService from '@jetbrains/ring-ui/components/auth-dialog-service/auth-dialog-service';\nimport hubConfig from '@ring-ui/docs/components/hub-config';\nimport '@jetbrains/ring-ui/components/link/link__legacy.css';\n\nconst auth = new Auth({\n  ...hubConfig,\n  EmbeddedLoginFlow: IFrameFlow\n});\nauth.setAuthDialogService(authDialogService);\n\n(async () => {\n  try {\n    const location = await auth.init();\n    await auth.login();\n    const data = await auth.requestUser();\n    document.getElementById('example').innerHTML = JSON.stringify(data);\n  } catch (e) {\n    console.error('Failed', e);\n  }\n})();\n  ",
          "showCode": true
        }
      ]
    },
    {
      "name": "Auth landing page",
      "url": "examples/auth/auth-landing-page.html",
      "disableAutoSize": false,
      "files": [
        {
          "type": "html",
          "content": "\n<div id=\"example\">\n  <div><a href=\"#\" id=\"open-link\" class=\"ring-link\">Open landing page</a></div>\n  <div><a href=\"#\" id=\"force-update\" class=\"ring-link\">Force token update</a></div>\n  <div><a href=\"#\" id=\"log-out\" class=\"ring-link\">Log out</a></div>\n  <div id=\"example\"></div>\n</div>\n  ",
          "showCode": true
        },
        {
          "type": "js",
          "content": "\nimport Auth from '@jetbrains/ring-ui/components/auth/auth';\nimport '@jetbrains/ring-ui/components/link/link__legacy.css';\nimport authService from '@jetbrains/ring-ui/components/auth-dialog-service/auth-dialog-service';\nimport hubConfig from '@ring-ui/docs/components/hub-config';\nimport LandingEntryFileName from '@jetbrains/ring-ui/components/auth/landing-entry';\n\nconst log = function (title, obj) {\n  const titleElem = document.createElement('b');\n  const jsonElem = document.createElement('span');\n  const lineBreak = document.createElement('br');\n  lineBreak.style.lineHeight = '32px';\n\n  titleElem.innerHTML = title + ' ';\n  jsonElem.innerHTML = JSON.stringify(obj) + '\\n';\n\n  document.getElementById('example').appendChild(titleElem);\n  document.getElementById('example').appendChild(jsonElem);\n  document.getElementById('example').appendChild(lineBreak);\n};\n\nasync function run() {\n  const auth = new Auth({\n    ...hubConfig,\n    redirectUri: hubConfig.redirectUri + LandingEntryFileName\n  });\n\n  auth.setAuthDialogService(authService);\n  await auth.init();\n\n  const user = await auth.requestUser();\n  log('Logged in as:', user.name)\n\n  document.querySelector('#open-link').href = LandingEntryFileName;\n\n  document.querySelector('#force-update').addEventListener('click', async () => {\n    const newToken = await auth.forceTokenUpdate();\n    log('New token:', newToken);\n  });\n\n  document.querySelector('#log-out').addEventListener('click', () => {\n    auth.login();\n  });\n}\n\nrun();\n\n  ",
          "showCode": true
        }
      ]
    }
  ],
  "description": "Authenticates a user in [Hub](https://www.jetbrains.com/hub/).",
  "attrs": {
    "name": "Auth",
    "category": "Utilities",
    "tags": "Ring UI Language",
    "description": "Authenticates a user in [Hub](https://www.jetbrains.com/hub/).",
    "prop": "{string[]} config.fetchCredentials",
    "param": "{{\n  serverUri: string,\n  redirectUri: string?,\n  requestCredentials: string?,\n  clientId: string?,\n  scope: string[]?,\n  optionalScopes: string[]?,\n  cleanHash: boolean?,\n  fetchCredentials: string?,\n  userFields: string[]?\n}} config",
    "example-file": "./auth.examples.html"
  }
};